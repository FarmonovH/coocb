"""1.1 O'zgaruchilarni alohida ketma ketlikda joylashtirishmasalan: sizda N ta leementdan tashkil topgan-ketma ketlik bor shuni bir nechta o'zgaruvchilarga joylashtirishyechim: har qanday ketma-ketlikni oddiy joylashtirish orqali ochish mumkinp = (3, 5)x, y = pdata = ["ACME", 58, 38.1, (31, 54)]a, b, c, d = datak, y = djoylashtirish xar qanday obyektlar bilan ishlaydis = "hello"a, b, c, d, k = smaslan _ chiziq bilan siz xoxlagan malumotni shunchaki tenglashtrib qo'yishingiz mumkindata = ["ACME", 32, 98, (2023, 0.5, 17)]a, b, c, _ = data"""import heapq"""1.2 ixtiyoriy elementlarni uzunlikdagi elmentlarni ketma-ketlikda joylashtirishtopshiriq: sizga kerak N ta elementlik o'zgaruvchilarga joylashtrish kerak, lekin bu ketma-ketlik ichida N tadan ko'p element bo'lishi mumkin buni * orqali hal qilishimiz mumkindef drop_frist_last(grades):    frist, *middle, last = grades    return middleprint(drop_frist_last([1, 2, 3, 4, 45, 60, 70, 100, 200]))ko'rib chiqamiz masalan sizda bir nechda elektron pochta nomidan iborat ketma-ketlik bor shu manzildagi telefon raqamlar kerak lekin foydalanuvchi bir nechta raqamdan iborat bo'lishi mumkin, yaki bo'lmasligi ham mumkinrecord = ("Ruzana", "almazar@gmail.com", "+9989013463472", "+99899234237", "+998974353224", "+9989523441245")name, email, *phone_numbers = recordprint(phone_numbers)*phone_numbers qilganimizda malumotlarni list ko'rinishida saqlaydisales_record = [1,2,56,35,6,5,4,3,556,6,6,6,43443,4]*trailling_qtrs, current_qtrs = sales_recordtrailling_avg = sum(trailling_qtrs)/len(trailling_qtrs)print(trailling_avg, current_qtrs)line = "nobody:*:-2:dufhdf:dbvehf/rfvier/fgwrgf/vfevwefv/febvweb/beqbe:/erfgewvqw/btew/true"name, *fields, homedir = line.split(":")print(name, fields, homedir)*_ => bu xammasini ununutib yuboradirecord = ("ACME", 50, 123, 45, (12, 18, 2023))name, *_, (*_, year) = recordprint(name, year)# items = [10, 7, 4, 5, 9]# def sum(items):#     head, *tail = items#        return head + sum(tail) if tail else head# # # print(sum(items))""""""1.3 oxiridan N ta elementini qoldirish topshiriq: siz xoxlaysiz # from collections import deque# def search(lines, pattern, history = 5):#     previous_lines = deque(maxlen=history)#     for line in lines:#         if pattern in line:#             yield line, previous_lines#         previous_lines.append(line)### if __name__ == "__main__":#     with open('somefile.txt') as f:from collections import dequeq = deque(maxlen=4)q.append(2)q.append(3)q.append(4)q.append(5)print(type(q))bu deque methodi istoriyalarni saqlashda ishlatiladi""""""1.4 N ta elementdan max ni yoki min aniqlash topshiriq: masalan nums degan kortejdan n ta max va n ta min aniqlashingiz kerak import heapqnums = [1, 3, 4,5,-8, 100, 45, -1]print(heapq.nlargest(3, nums))print(heapq.nsmallest(3, nums))bu usulxam bor uncha yomon emas nums = [1, 3, 4,5,-8, 100, 45, -1]print(sorted(nums)[:3])portfolio = [    {"name": "IBM", "shares":10, "price": 90.1},    {"name": "AAPLE", "shares":90, "price": 90},    {"name": "FB", "shares":101, "price": 95},    {"name": "HPQ", "shares":100, "price": 70},    {"name": "EHOO", "shares":190, "price": 60},    {"name": "ACME", "shares":101, "price": 50},             ]cheep = heapq.nsmallest(3, portfolio, key=lambda x: x["price"])cheep = heapq.nlargest(4, portfolio, key=lambda x: x["shares"])print(cheep)nums = [1, 3, 4,5,-8, 100, 45, -1]a = heapq.heappop(nums)b = heapq.heappop(nums)c = heapq.heappop(nums)print(a, b, c, nums)print(help(heapq.heapify))""""""1.5 """